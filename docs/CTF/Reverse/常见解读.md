
## 数组赋值
```c
*(_DWORD *)(v2 + 4 * result + 84) = *(_DWORD *)(v2 + 4LL * a1);
// => 一个数组的a1[i]赋值到另一数组 a2[j]
ptr->Memory[result] = ptr->reg.R[a1];
```
## 8bytes 赋值a2
```c
__int64 __fastcall sub_401EFB(int a1, _DWORD *a2)
{
  __int64 result; // rax

  *a2 = HIBYTE(a1);
  a2[1] = BYTE2(a1);
  a2[2] = BYTE1(a1);
  result = (unsigned __int8)a1;
  a2[3] = (unsigned __int8)a1;
  return result;
}
```

## 循环左移
```c
__int64 __fastcall sub_401F67(__int64 a1, unsigned int n1)
{
  __int64 result;
  int a2[6];
  int vn1;
  int i;

  for ( i = 0; i <= 3; ++i )
    a2[i] = *(_DWORD *)(4i64 * i + a1);         // v3=a[i]
  result = n1;
  vn1 = n1;
  for ( i = 0; i <= 3; ++i )
  {
    *(_DWORD *)(a1 + 4i64 * i) = a2[vn1++];     // a[i]=v3[j++]
                                                // vn1值 -> 1 2 3 0
                                                // 左侧a  -> 0 1 2 3  所以是循环左移
    result = (unsigned int)(vn1 % 4);
    vn1 %= 4;
  }
  return result;
}
```